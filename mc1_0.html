<!DOCTYPE html>
<html lang="en" style="width:100%;height:100%;">
  <head>
    <meta charset="utf-8">
    <title>CJ3 test</title>
    <script src="https://127.0.0.1:8084/cj3loader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/3.4.2/gl-matrix-min.js" referrerpolicy="no-referrer"></script>
  </head>
  <body style="width:100%;height:100%;margin:0;">
   <canvas id="mc" width="1024" height="768"></canvas>
   <div id="display" style="width:100%;height:100%;position:absolute;top:0;left:0px;visibility:hidden;">
   </div>
   <script>
	var mcCanvas = document.getElementById("mc");
	var mcCtx = mcCanvas.getContext("webgl2", {antialias: false, alpha: false});
	var vertexShaderSrc = `
		attribute vec4 aVertexPosition;
		attribute vec4 aColor;
		attribute vec2 aTexCoord;
		uniform mat4 modelView;
		uniform mat4 projection;
		varying vec2 vTexCoord;
		varying vec4 vColor;
		void main() {
			gl_Position = projection * modelView * aVertexPosition;
			vTexCoord = aTexCoord;
			vColor = aColor;
		}
	`;
	// NOTE: Only the default GL_MODULATE texEnv is supported here
	var fragmentShaderSrc = `
		precision mediump float;
		uniform float uTextureMask;
		uniform sampler2D uSampler;
		varying vec2 vTexCoord;
		varying vec4 vColor;
		void main() {
			vec4 texSample = texture2D(uSampler, vTexCoord);
			vec4 colorValue = vColor * (1.0 - uTextureMask);
			vec4 texValue = vColor * texSample * uTextureMask;
			gl_FragColor = colorValue + texValue;
		}
	`;
	var vertexShader = mcCtx.createShader(mcCtx.VERTEX_SHADER);
	mcCtx.shaderSource(vertexShader, vertexShaderSrc);
	mcCtx.compileShader(vertexShader);
	var fragmentShader = mcCtx.createShader(mcCtx.FRAGMENT_SHADER);
	mcCtx.shaderSource(fragmentShader, fragmentShaderSrc);
	mcCtx.compileShader(fragmentShader);
	var program = mcCtx.createProgram();
	mcCtx.attachShader(program, vertexShader);
	mcCtx.attachShader(program, fragmentShader);
	mcCtx.linkProgram(program);
	mcCtx.useProgram(program);
	var vertexBuffer = mcCtx.createBuffer();
	var colorBuffer = mcCtx.createBuffer();
	var texCoordBuffer = mcCtx.createBuffer();
	var vertexPosition = mcCtx.getAttribLocation(program, "aVertexPosition");
	var colorLocation = mcCtx.getAttribLocation(program, "aColor");
	var texCoord = mcCtx.getAttribLocation(program, "aTexCoord");
	var mvLocation = mcCtx.getUniformLocation(program, "modelView");
	var projLocation = mcCtx.getUniformLocation(program, "projection");
	var samplerLocation = mcCtx.getUniformLocation(program, "uSampler");
	var texMaskLocation = mcCtx.getUniformLocation(program, "uTextureMask");
	var vertexData =
	{
		enabled: false,
		size: 0,
		type: 0,
		stride: 0,
		pointer: 0,
		buf: null
	};
	var colorData =
	{
		enabled: false,
		size: 0,
		type: 0,
		stride: 0,
		pointer: 0,
		buf: null
	};
	var texCoordData =
	{
		enabled: false,
		size: 0,
		type: 0,
		stride: 0,
		pointer: 0,
		buf: null
	};
	var frameCount = 0;
	// Set to a non-zero value to stop after a certain number of frames
	var frameLimit = 0;
	// NOTE: These initializes to identity
	var projMatrixStack = [glMatrix.mat4.create()];
	var modelViewMatrixStack = [glMatrix.mat4.create()];
	var textureMatrixStack = [glMatrix.mat4.create()];
	var curMatrixStack = modelViewMatrixStack;
	function getCurMatrixTop()
	{
		return curMatrixStack[curMatrixStack.length - 1];
	}
	function setCurMatrixTop(m)
	{
		curMatrixStack[curMatrixStack.length - 1] = m;
	}
	function uploadData(v, data, buffer, attributeLocation, count)
	{
		if(data.enabled)
		{
			assert(data.stride);
			var buf = data.buf;
			if(buf == null)
			{
				assert(v && data.pointer);
				buf = new Uint8Array(v.buffer, data.pointer, data.stride * count);
			}
			mcCtx.bindBuffer(mcCtx.ARRAY_BUFFER, buffer);
			mcCtx.bufferData(mcCtx.ARRAY_BUFFER, buf, mcCtx.STATIC_DRAW);
			mcCtx.vertexAttribPointer(attributeLocation, data.size, data.type, data.type != mcCtx.FLOAT, data.stride, 0);
			mcCtx.enableVertexAttribArray(attributeLocation);
		}
		else
		{
			mcCtx.disableVertexAttribArray(attributeLocation);
		}
	}
	function captureData(v, data, count)
	{
		var ret = { enabled: data.enabled, size: data.size, type: data.type, stride: data.stride, pointer: 0, buf: null };
		if(data.enabled)
		{
			assert(data.stride);
			var buf = new Uint8Array(v.buffer, data.pointer, data.stride * count);
			// Capture the current data
			ret.buf = new Uint8Array(buf);
		}
		return ret;
	}
	function checkNoList(list)
	{
		if(list != null)
			throw new Error("Unsupported command in list");
	}
	function pushInList(list, args)
	{
		// Not an elegant solution, but it works
		// It would be nicer to extract the actual implementation from native interfaces
		// to avoid bringing around the library object
		list.push({f: args.callee, a: Array.from(args)});
	}
	function callList(listId)
	{
		var l = cmdLists[listId];
		for(var i=0;i<l.length;i++)
		{
			var c = l[i];
			c.f.apply(null, c.a);
		}
	}
	function drawArraysImpl(mode, first, count)
	{
		// TODO: Conditional
		mcCtx.uniformMatrix4fv(mvLocation, false, modelViewMatrixStack[modelViewMatrixStack.length - 1]);
		mcCtx.uniformMatrix4fv(projLocation, false, projMatrixStack[projMatrixStack.length - 1]);
		assert(first == 0);
		// We can render each quad a separate GL_TRIANGLE_FAN
		if(mode == 7/*QUADS*/ && (count % 4) == 0)
		{
			for(var i=0;i<count;i+=4)
				mcCtx.drawArrays(mcCtx.TRIANGLE_FAN, i, 4);
		}
		else if(mode == mcCtx.LINES || mode == mcCtx.LINE_STRIP || mode == mcCtx.TRIANGLE_FAN)
		{
			mcCtx.drawArrays(mode, first, count);
		}
		else
		{
			debugger;
		}
	}
	function pushDrawArraysInList(list, v, mode, first, count)
	{
		var args = [mode, first, count, captureData(v, vertexData, count), captureData(v, colorData, count), captureData(v, texCoordData, count)];
		list.push({f: drawArraysInList, a: args});
	}
	function drawArraysInList(mode, first, count, capturedVertexData, capturedColorData, capturedTexCoordData)
	{
		// Upload vertex data
		uploadData(null, capturedVertexData, vertexBuffer, vertexPosition, count);
		// Upload color data
		uploadData(null, capturedColorData, colorBuffer, colorLocation, count);
		// Upload tex coord data
		uploadData(null, capturedTexCoordData, texCoordBuffer, texCoord, count);
		drawArraysImpl(mode, first, count);
	}
	// Fix the sampler to texture unit 0
	mcCtx.uniform1i(samplerLocation, 0);
	var curList = null;
	var cmdLists = [null];
	// The first null implicitly solves resetting on 0 id
	var textureObjects = [null];
	// We need to use an FBO as the main target to support copyTexSubImage2D that seems broken otherwise
	var fbTexture = mcCtx.createTexture();
	mcCtx.bindTexture(mcCtx.TEXTURE_2D, fbTexture);
	mcCtx.texImage2D(mcCtx.TEXTURE_2D, 0, mcCtx.RGBA, 1024, 768, 0, mcCtx.RGBA, mcCtx.UNSIGNED_BYTE, null);
	mcCtx.bindTexture(mcCtx.TEXTURE_2D, null);
	var mainFb = mcCtx.createFramebuffer();
	mcCtx.bindFramebuffer(mcCtx.READ_FRAMEBUFFER, mainFb);
	mcCtx.bindFramebuffer(mcCtx.DRAW_FRAMEBUFFER, mainFb);
	mcCtx.framebufferTexture2D(mcCtx.FRAMEBUFFER, mcCtx.COLOR_ATTACHMENT0, mcCtx.TEXTURE_2D, fbTexture, 0);
	// Synthetize a focus event, it's needed for LWJGL logic
	var eventQueue = [{type:"focus"}];
	mcCanvas.addEventListener("mousemove", function(e)
	{
		// TODO: Merge events
		if(eventQueue.length)
			return;
		eventQueue.push({type:e.type, x:e.clientX, y:e.clientY});
	});
	mcCanvas.addEventListener("mousedown", function(e)
	{
		eventQueue.push({type:e.type, x:e.clientX, y:e.clientY});
	});
	mcCanvas.addEventListener("mouseup", function(e)
	{
		eventQueue.push({type:e.type, x:e.clientX, y:e.clientY});
	});
	var mcNatives =
	{
		Java_org_lwjgl_DefaultSysImplementation_getPointerSize()
		{
			return 4;
		},
		Java_org_lwjgl_DefaultSysImplementation_getJNIVersion()
		{
			return 19;
		},
		Java_org_lwjgl_DefaultSysImplementation_setDebug()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nLockAWT()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nUnlockAWT()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplay_setErrorHandler()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplay_openDisplay()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nInternAtom()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nIsXrandrSupported()
		{
			return 0;
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nIsXF86VidModeSupported()
		{
			return 1;
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nGetDefaultScreen()
		{
			return 0;
		},
		async Java_org_lwjgl_opengl_LinuxDisplay_nGetAvailableDisplayModes(lib)
		{
			var DisplayMode = await lib.org.lwjgl.opengl.DisplayMode;
			var d = await new DisplayMode(1024, 768);
			return [d];
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nGetCurrentGammaRamp()
		{
		},
		Java_org_lwjgl_opengl_LinuxPeerInfo_createHandle()
		{
		},
		Java_org_lwjgl_opengl_GLContext_nLoadOpenGLLibrary()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplayPeerInfo_initDefaultPeerInfo()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplayPeerInfo_initDrawable()
		{
		},
		Java_org_lwjgl_opengl_AWTSurfaceLock_createHandle()
		{
		},
		Java_org_lwjgl_opengl_AWTSurfaceLock_lockAndInitHandle()
		{
			return 1;
		},
		Java_org_lwjgl_opengl_LinuxAWTGLCanvasPeerInfo_getScreenFromSurfaceInfo()
		{
		},
		Java_org_lwjgl_opengl_LinuxAWTGLCanvasPeerInfo_nInitHandle()
		{
		},
		Java_org_lwjgl_opengl_AWTSurfaceLock_nUnlock()
		{
		},
		Java_org_lwjgl_opengl_LinuxPeerInfo_nGetDrawable()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nCreateWindow()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplay_mapRaised()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nCreateBlankCursor()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nSetTitle()
		{
		},
		Java_org_lwjgl_opengl_LinuxMouse_nGetButtonCount()
		{
			// TODO: Expand for right click
			return 1;
		},
		Java_org_lwjgl_opengl_LinuxMouse_nQueryPointer()
		{
		},
		Java_org_lwjgl_opengl_LinuxMouse_nGetWindowHeight()
		{
			return 768;
		},
		Java_org_lwjgl_opengl_LinuxKeyboard_getModifierMapping()
		{
		},
		Java_org_lwjgl_opengl_LinuxKeyboard_nSetDetectableKeyRepeat()
		{
		},
		Java_org_lwjgl_opengl_LinuxKeyboard_openIM()
		{
		},
		Java_org_lwjgl_opengl_LinuxKeyboard_allocateComposeStatus()
		{
		},
		Java_org_lwjgl_opengl_LinuxContextImplementation_nCreate()
		{
		},
		Java_org_lwjgl_opengl_LinuxContextImplementation_nMakeCurrent()
		{
		},
		Java_org_lwjgl_opengl_GLContext_ngetFunctionAddress(lib, stringPtr)
		{
			// Return any non-zero address, methods are called by name anyway
			return 1;
		},
		Java_org_lwjgl_opengl_GL11_nglGetString(lib, id, funcPtr)
		{
			checkNoList(curList);
			// Special case GL_EXTENSION for now
			if(id == 0x1F03)
			{
				// TODO: Do we need any?
				return "";
			}
			else
			{
				return mcCtx.getParameter(id);
			}
		},
		Java_org_lwjgl_opengl_GL11_nglGetIntegerv(lib, id, memPtr, funcPtr)
		{
			checkNoList(curList);
			var v = lib.getJNIDataView();
			var buf = new Int32Array(v.buffer, Number(memPtr), 4);
			if(id == /*GL_VIEWPORT*/0xba2)
			{
				buf[0] = 0;
				buf[1] = 0;
				buf[2] = 1024;
				buf[3] = 768;
			}
			else
			{
				console.log("glGetInteger", id);
			}
		},
		Java_org_lwjgl_opengl_GL11_nglGetError()
		{
			checkNoList(curList);
			// We like living dangerously
			return 0;
		},
		Java_org_lwjgl_opengl_LinuxContextImplementation_nSetSwapInterval()
		{
		},
		Java_org_lwjgl_opengl_GL11_nglClearColor(lib, r, g, b, a, funcPtr)
		{
			checkNoList(curList);
			return mcCtx.clearColor(r, g, b, a);
		},
		Java_org_lwjgl_opengl_GL11_nglClear(lib, a, funcPtr)
		{
			checkNoList(curList);
			mcCtx.clear(a);
		},
		Java_org_lwjgl_opengl_LinuxContextImplementation_nSwapBuffers()
		{
			console.warn("SwapBuffer");
			mcCtx.bindFramebuffer(mcCtx.DRAW_FRAMEBUFFER, null);
			mcCtx.blitFramebuffer(0, 0, 1024, 768, 0, 0, 1024, 768, mcCtx.COLOR_BUFFER_BIT, mcCtx.NEAREST);
			mcCtx.bindFramebuffer(mcCtx.DRAW_FRAMEBUFFER, mainFb);
			frameCount++;
			if(frameCount == 0)
			{
				console.warn("Stopping");
				return new Promise(function(){});
			}
			return new Promise(function(f, r)
			{
				requestAnimationFrame(f);
			});
		},
		Java_org_lwjgl_opengl_LinuxEvent_getPending()
		{
			return eventQueue.length;
		},
		Java_org_lwjgl_opengl_GL11_nglMatrixMode(lib, matrixMode, funcPtr)
		{
			if(curList)
				return pushInList(curList, arguments);
			if(matrixMode == 0x1700/*GL_MODELVIEW*/)
				curMatrixStack = modelViewMatrixStack;
			else if(matrixMode == 0x1701/*GL_PROJECTION*/)
				curMatrixStack = projMatrixStack;
			else if(matrixMode == 0x1702/*GL_TEXTURE*/)
				curMatrixStack = textureMatrixStack;
			else
				debugger;
		},
		Java_org_lwjgl_opengl_GL11_nglLoadIdentity(lib, funcPtr)
		{
			checkNoList(curList);
			glMatrix.mat4.identity(getCurMatrixTop());
		},
		Java_org_lwjgl_opengl_GL11_nglOrtho(lib, left, right, bottom, top, nearVal, farVal, funcPtr)
		{
			checkNoList(curList);
			var m = getCurMatrixTop();
			var o = glMatrix.mat4.create();
			glMatrix.mat4.ortho(o, left, right, bottom, top, nearVal, farVal);
			var out = glMatrix.mat4.create();
			setCurMatrixTop(glMatrix.mat4.multiply(out, m, o));
		},
		Java_org_lwjgl_opengl_GL11_nglTranslatef(lib, x, y, z, funcPtr)
		{
			if(curList)
				return pushInList(curList, arguments);
			var m = getCurMatrixTop();
			var out = glMatrix.mat4.create();
			setCurMatrixTop(glMatrix.mat4.translate(out, m, glMatrix.vec3.fromValues(x, y, z)));
		},
		Java_org_lwjgl_opengl_GL11_nglViewport(lib, x, y, width, height, funcPtr)
		{
			checkNoList(curList);
			mcCtx.viewport(x, y, width, height);
		},
		Java_org_lwjgl_opengl_GL11_nglDisable(lib, a, funcPtr)
		{
			checkNoList(curList);
			if(a == mcCtx.BLEND)
				mcCtx.disable(a);
			else if(a == 0xde1/*GL_TEXTURE_2D*/)
				mcCtx.uniform1f(texMaskLocation, 0);
			else
				console.log("glDisable " + a.toString(16));
		},
		Java_org_lwjgl_opengl_GL11_nglEnable(lib, a, funcPtr)
		{
			checkNoList(curList);
			if(a == mcCtx.BLEND)
				mcCtx.enable(a);
			else if(a == 0xde1/*GL_TEXTURE_2D*/)
				mcCtx.uniform1f(texMaskLocation, 1);
			else
				console.log("glEnable " + a.toString(16));
		},
		Java_org_lwjgl_opengl_GL11_nglGenTextures(lib, n, memPtr, funcPtr)
		{
			checkNoList(curList);
			var v = lib.getJNIDataView();
			var buf = new Int32Array(v.buffer, Number(memPtr), n);
			for(var i=0;i<n;i++)
			{
				var id = textureObjects.length;
				buf[i] = id;
				textureObjects[id] = mcCtx.createTexture();
			}
		},
		Java_org_lwjgl_opengl_GL11_nglBindTexture(lib, target, id, funcPtr)
		{
			checkNoList(curList);
			assert(target == mcCtx.TEXTURE_2D);
			mcCtx.bindTexture(target, textureObjects[id]);
		},
		Java_org_lwjgl_opengl_GL11_nglTexParameteri(lib, target, pname, param, funcPtr)
		{
			checkNoList(curList);
			mcCtx.texParameteri(target, pname, param);
		},
		Java_org_lwjgl_opengl_GL11_nglTexImage2D(lib, target, level, internalFormat, width, height, border, format, type, memPtr, funcPtr)
		{
			checkNoList(curList);
			assert(target == mcCtx.TEXTURE_2D);
			var v = lib.getJNIDataView();
			// Build an unbound array, WebGL will truncate as needed
			var buf = new Uint8Array(v.buffer, Number(memPtr));
			mcCtx.texImage2D(target, level, internalFormat, width, height, border, format, type, buf);
		},
		Java_org_lwjgl_opengl_GL11_nglTexCoordPointer(lib, size, type, stride, memPtr, funcPtr)
		{
			texCoordData.size = size;
			texCoordData.type = type;
			texCoordData.stride = stride;
			texCoordData.pointer = Number(memPtr);
		},
		Java_org_lwjgl_opengl_GL11_nglEnableClientState(lib, v, funcPtr)
		{
			if(v == 0x8074/*GL_VERTEX_ARRAY*/)
			{
				vertexData.enabled = true;
			}
			else if(v == 0x8076/*GL_COLOR_ARRAY*/)
			{
				colorData.enabled = true;
			}
			else if(v == 0x8078/*GL_TEXTURE_COORD_ARRAY*/)
			{
				texCoordData.enabled = true;
			}
			else
			{
				console.log("glEnableClientState");
			}
		},
		Java_org_lwjgl_opengl_GL11_nglColorPointer(lib, size, type, stride, memPtr, funcPtr)
		{
			colorData.size = size;
			colorData.type = type;
			colorData.stride = stride;
			colorData.pointer = Number(memPtr);
		},
		Java_org_lwjgl_opengl_GL11_nglVertexPointer(lib, size, type, stride, memPtr, funcPtr)
		{
			vertexData.size = size;
			vertexData.type = type;
			vertexData.stride = stride;
			vertexData.pointer = Number(memPtr);
		},
		Java_org_lwjgl_opengl_GL11_nglDrawArrays(lib, mode, first, count, funcPtr)
		{
			var v = lib.getJNIDataView();
			if(curList)
			{
				// Capture client state at this point in time
				return pushDrawArraysInList(curList, v, mode, first, count);
			}
			// Upload vertex data
			uploadData(v, vertexData, vertexBuffer, vertexPosition, count);
			// Upload color data
			uploadData(v, colorData, colorBuffer, colorLocation, count);
			// Upload tex coord data
			uploadData(v, texCoordData, texCoordBuffer, texCoord, count);
			drawArraysImpl(mode, first, count);
		},
		Java_org_lwjgl_opengl_GL11_nglDisableClientState(lib, v, funcPtr)
		{
			if(v == 0x8074/*GL_VERTEX_ARRAY*/)
			{
				vertexData.enabled = false;
			}
			else if(v == 0x8076/*GL_COLOR_ARRAY*/)
			{
				colorData.enabled = false;
			}
			else if(v == 0x8078/*GL_TEXTURE_COORD_ARRAY*/)
			{
				texCoordData.enabled = false;
			}
			else
			{
				console.log("glDisableClientState");
			}
		},
		Java_org_lwjgl_opengl_GL11_nglColor4f(lib, r, g, b, a, funcPtr)
		{
			checkNoList(curList);
			mcCtx.vertexAttrib4f(colorLocation, r, g, b, a);
		},
		Java_org_lwjgl_opengl_GL11_nglAlphaFunc()
		{
			checkNoList(curList);
			console.log("glAlphaFunc");
		},
		Java_org_lwjgl_opengl_GL11_nglGenLists(lib, range, funcPtr)
		{
			checkNoList(curList);
			var ret = cmdLists.length;
			for(var i=0;i<range;i++)
				cmdLists.push([]);
			return ret;
		},
		Java_org_lwjgl_opengl_GL11_nglNewList(lib, list, mode, funcPtr)
		{
			checkNoList(curList);
			assert(mode == 0x1300/*GL_COMPILE*/);
			curList = cmdLists[list];
			assert(curList.length == 0);
		},
		Java_org_lwjgl_opengl_GL11_nglEndList(lib, funcPtr)
		{
			curList = null;
		},
		Java_org_lwjgl_opengl_GL11_nglColor3f()
		{
			if(curList)
				return pushInList(curList, arguments);
			console.log("glColor3f");
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nGetNativeCursorCapabilities()
		{
		},
		Java_org_lwjgl_opengl_GL11_nglShadeModel()
		{
			checkNoList(curList);
			console.log("glShaderModel");
		},
		Java_org_lwjgl_opengl_GL11_nglClearDepth()
		{
			checkNoList(curList);
			console.log("glClearDepth");
		},
		Java_org_lwjgl_opengl_GL11_nglDepthFunc()
		{
			checkNoList(curList);
			console.log("glDepthFunc");
		},
		Java_org_lwjgl_opengl_GL11_nglCullFace()
		{
			checkNoList(curList);
			console.log("glCullFace");
		},
		Java_org_lwjgl_opengl_GL11_nglPushMatrix(lib, funcPtr)
		{
			if(curList)
				return pushInList(curList, arguments);
			curMatrixStack.push(glMatrix.mat4.clone(curMatrixStack[curMatrixStack.length - 1]));
		},
		Java_org_lwjgl_opengl_GL11_nglPopMatrix(lib, funcPtr)
		{
			if(curList)
				return pushInList(curList, arguments);
			curMatrixStack.pop();
		},
		Java_org_lwjgl_opengl_GL11_nglMultMatrixf(lib, memPtr, funcPtr)
		{
			checkNoList(curList);
			var m = getCurMatrixTop();
			var v = lib.getJNIDataView();
			var buf = new Float32Array(v.buffer, Number(memPtr), 16);
			var out = glMatrix.mat4.create();
			setCurMatrixTop(glMatrix.mat4.multiply(out, m, buf));
		},
		Java_org_lwjgl_opengl_GL11_nglRotatef(lib, angle, x, y, z, funcPtr)
		{
			checkNoList(curList);
			var m = getCurMatrixTop();
			var out = glMatrix.mat4.create();
			setCurMatrixTop(glMatrix.mat4.rotate(out, m, angle * Math.PI / 180.0, glMatrix.vec3.fromValues(x, y, z)));
		},
		Java_org_lwjgl_opengl_GL11_nglDepthMask()
		{
			checkNoList(curList);
			console.log("glDepthMask");
		},
		Java_org_lwjgl_opengl_GL11_nglBlendFunc(lib, sfactor, dfactor)
		{
			checkNoList(curList);
			mcCtx.blendFunc(sfactor, dfactor);
		},
		Java_org_lwjgl_opengl_GL11_nglColorMask(lib, r, g, b, a, funcPtr)
		{
			checkNoList(curList);
			mcCtx.colorMask(r, g, b, a);
		},
		Java_org_lwjgl_opengl_GL11_nglCopyTexSubImage2D(lib, target, level, xoffset, yoffset, x, y, width, height, funcPtr)
		{
			checkNoList(curList);
			mcCtx.copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
		},
		Java_org_lwjgl_opengl_GL11_nglScalef(lib, x, y, z, funcPtr)
		{
			if(curList)
				return pushInList(curList, arguments);
			var m = getCurMatrixTop();
			var out = glMatrix.mat4.create();
			setCurMatrixTop(glMatrix.mat4.scale(out, m, glMatrix.vec3.fromValues(x, y, z)));
		},
		Java_org_lwjgl_opengl_GL11_nglCallLists(lib, n, type, memPtr, funcPtr)
		{
			checkNoList(curList);
			assert(type == mcCtx.UNSIGNED_INT);
			var v = lib.getJNIDataView();
			var buf = new Int32Array(v.buffer, Number(memPtr), n);
			for(var i=0;i<n;i++)
				callList(buf[i]);
		},
		Java_org_lwjgl_opengl_GL11_nglFlush()
		{
			checkNoList(curList);
			mcCtx.flush();
		},
		Java_org_lwjgl_opengl_GL11_nglTexSubImage2D(lib, target, level, xoffset, yoffset, width, height, format, type, memPtr, funcPtr)
		{
			checkNoList(curList);
			assert(target == mcCtx.TEXTURE_2D);
			var v = lib.getJNIDataView();
			// Build an unbound array, WebGL will truncate as needed
			var buf = new Uint8Array(v.buffer, Number(memPtr));
			mcCtx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, buf);
		},
		Java_org_lwjgl_opengl_GL11_nglGetFloatv(lib, a, memPtr, funcPtr)
		{
			checkNoList(curList);
			var v = lib.getJNIDataView();
			var buf = new Float32Array(v.buffer, Number(memPtr), 16);
			if(a == /*GL_MODELVIEW_MATRIX*/0xba6)
			{
				var m = modelViewMatrixStack[modelViewMatrixStack.length - 1];
				for(var i=0;i<16;i++)
					buf[i] = m[i];
			}
			else if(a == /*GL_PROJECTION_MATRIX*/0xba7)
			{
				var m = projMatrixStack[projMatrixStack.length - 1];
				for(var i=0;i<16;i++)
					buf[i] = m[i];
			}
			else
			{
				console.log("glGetFloat "+a);
			}
		},
		Java_org_lwjgl_opengl_GL11_nglFogfv()
		{
			checkNoList(curList);
			console.log("glFog");
		},
		Java_org_lwjgl_opengl_GL11_nglNormal3f()
		{
			checkNoList(curList);
			console.log("glNormal3f");
		},
		Java_org_lwjgl_opengl_GL11_nglFogi()
		{
			checkNoList(curList);
			console.log("glFogi");
		},
		Java_org_lwjgl_opengl_GL11_nglFogf()
		{
			checkNoList(curList);
			console.log("glFogf");
		},
		Java_org_lwjgl_opengl_GL11_nglColorMaterial()
		{
			checkNoList(curList);
			console.log("glColorMaterial");
		},
		Java_org_lwjgl_opengl_GL11_nglCallList(lib, listId, funcPtr)
		{
			checkNoList(curList);
			callList(listId);
		},
		Java_org_lwjgl_opengl_GL13_nglActiveTexture()
		{
			checkNoList(curList);
			console.log("glActiveTexture");
		},
		Java_org_lwjgl_opengl_GL11_nglLightfv()
		{
			checkNoList(curList);
			console.log("glLightfv");
		},
		Java_org_lwjgl_opengl_GL11_nglLightModelfv()
		{
			checkNoList(curList);
			console.log("glLightModelfv");
		},
		Java_org_lwjgl_opengl_GL11_nglNormalPointer()
		{
			console.log("glNormalPointer");
		},
		Java_org_lwjgl_opengl_GL13_nglMultiTexCoord2f()
		{
			checkNoList(curList);
			console.log("glMultiTexCoord2f");
		},
		Java_org_lwjgl_opengl_GL13_nglClientActiveTexture()
		{
			console.log("glClientActiveTexture");
		},
		Java_org_lwjgl_opengl_GL11_nglLineWidth()
		{
			checkNoList(curList);
			console.log("glLineWidth");
		},
		// These stubs make sure audio creation fails sooner rather than later
		Java_org_lwjgl_openal_AL_nCreate()
		{
		},
		Java_org_lwjgl_openal_AL10_initNativeStubs()
		{
		},
		Java_org_lwjgl_openal_ALC10_initNativeStubs()
		{
		},
		Java_org_lwjgl_openal_ALC10_nalcOpenDevice()
		{
		},
		Java_org_lwjgl_openal_AL_resetNativeStubs()
		{
		},
		Java_org_lwjgl_openal_AL_nDestroy()
		{
		},
		// Basic input support
		async Java_org_lwjgl_opengl_LinuxEvent_createEventBuffer(lib)
		{
			// This is intended to represent a X11 event, but we are free to use any layout
			var ByteBuffer = await lib.java.nio.ByteBuffer;
			return await ByteBuffer.allocateDirect(12);
		},
		async Java_org_lwjgl_opengl_LinuxEvent_nNextEvent(lib, windowId, buffer)
		{
			// Resolve the address and directly access the JNI memory
			var bufferAddr = Number(await buffer.address());
			var v = lib.getJNIDataView();
			var e = eventQueue.shift();
			switch(e.type)
			{
				case "focus":
					v.setInt32(0, /*FocusIn*/9, true);
					break;
				case "mousedown":
					v.setInt32(0, /*ButtonPress*/4, true);
					v.setInt32(4, e.x, true);
					v.setInt32(8, e.y, true);
					break;
				case "mouseup":
					v.setInt32(0, /*ButtonRelease*/5, true);
					v.setInt32(4, e.x, true);
					v.setInt32(8, e.y, true);
					break;
				case "mousemove":
					v.setInt32(0, /*MotionNotify*/6, true);
					v.setInt32(4, e.x, true);
					v.setInt32(8, e.y, true);
					break;
				default:
					debugger;
			}
		},
		Java_org_lwjgl_opengl_LinuxEvent_nGetWindow()
		{
			// Only a single window is emulated
			return 0;
		},
		async Java_org_lwjgl_opengl_LinuxEvent_nGetType(lib, buffer)
		{
			var bufferAddr = Number(await buffer.address());
			var v = lib.getJNIDataView();
			return v.getInt32(0, true);
		},
		Java_org_lwjgl_opengl_LinuxEvent_nFilterEvent()
		{
		},
		Java_org_lwjgl_opengl_LinuxEvent_nGetButtonTime()
		{
			// TODO: Event timestamps
		},
		Java_org_lwjgl_opengl_LinuxEvent_nGetButtonRoot()
		{
		},
		async Java_org_lwjgl_opengl_LinuxEvent_nGetButtonXRoot(lib, buffer)
		{
			var bufferAddr = Number(await buffer.address());
			var v = lib.getJNIDataView();
			return v.getInt32(4, true);
		},
		async Java_org_lwjgl_opengl_LinuxEvent_nGetButtonYRoot(lib, buffer)
		{
			var bufferAddr = Number(await buffer.address());
			var v = lib.getJNIDataView();
			return v.getInt32(8, true);
		},
		async Java_org_lwjgl_opengl_LinuxEvent_nGetButtonX(lib, buffer)
		{
			var bufferAddr = Number(await buffer.address());
			var v = lib.getJNIDataView();
			return v.getInt32(4, true);
		},
		async Java_org_lwjgl_opengl_LinuxEvent_nGetButtonY(lib, buffer)
		{
			var bufferAddr = Number(await buffer.address());
			var v = lib.getJNIDataView();
			return v.getInt32(8, true);
		},
		Java_org_lwjgl_opengl_LinuxEvent_nGetFocusDetail()
		{
		},
		async Java_org_lwjgl_opengl_LinuxEvent_nGetButtonType(lib, buffer)
		{
			// Same as type, apparently
			var bufferAddr = Number(await buffer.address());
			var v = lib.getJNIDataView();
			return v.getInt32(0, true);
		},
		Java_org_lwjgl_opengl_LinuxEvent_nGetButtonButton()
		{
			// X11 button 1 (left)
			return 1;
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nGrabPointer()
		{
		},
		Java_org_lwjgl_opengl_LinuxDisplay_nDefineCursor()
		{
		},
		Java_org_lwjgl_opengl_LinuxMouse_nGetWindowWidth()
		{
			return 1024;
		},
		Java_org_lwjgl_opengl_LinuxMouse_nSendWarpEvent()
		{
		},
		Java_org_lwjgl_opengl_LinuxMouse_nWarpCursor()
		{
		},
	};
	async function initialize()
	{
		try
		{
			var ret = await cheerpjInit({version:8,javaProperties:["java.library.path=/app/fad31287c147bbc4f8e083a2b1f59d0b007e4ce2", "minecraft.launcher.brand=minecraft-launcher", "minecraft.launcher.version=2.14.12", "minecraft.client.jar=/app1.0.jar", "org.lwjgl.util.NoChecks=true"]/*,tailscaleAuthKey:"tskey-auth-kKvFtB6CNTRL-6PMx5d1cuRBAk2B2GpfdXBMHNMFjkxkZc"*/,natives:mcNatives});
			cheerpjCreateDisplay(-1, -1, document.getElementById("display"));
			var mainRet = await cheerpjRunMain("net.minecraft.launchwrapper.Launch", "/app/launchwrapper-1.5.jar:/app/jopt-simple-4.5.jar:/app/asm-all-4.1.jar:/app/jinput-2.0.5.jar:/app/jutils-1.0.0.jar:/app/lwjgl-2.9.0.jar:/app/lwjgl_util-2.9.0.jar:/app/1.0.jar", "--gameDir", "/files/");
			console.log("Java process exit code:", mainRet, "elapsed:", performance.now());
		}
		catch(e)
		{
			console.log("Failure:", e);
		}
	}
	initialize();
    </script>
  </body>
</html>
